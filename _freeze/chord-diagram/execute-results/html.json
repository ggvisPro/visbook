{
  "hash": "66a7ff53f580a198742167b26175825f",
  "result": {
    "engine": "knitr",
    "markdown": "# Chord Diagram {#sec-chord-diagram}\n\n## PKG\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(circlize)   # 绘制弦图的核心包\nlibrary(migest)     # 用于分析人口迁移数据\nlibrary(tidyverse)  # 数据处理与可视化核心包\nlibrary(viridis)    # 提供美观的调色板\nlibrary(patchwork)  # 用于组合图形\nlibrary(hrbrthemes) # 提供额外的主题\nlibrary(chorddiag)  # 绘制交互式弦图\n```\n:::\n\n\n## `circlize`\n\n### 基本\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 加载 circlize 包\nlibrary(circlize)\n\n# 创建示例数据集\ndata <- data.frame(\n  factor = sample(letters[1:8], 1000, replace = TRUE), # 创建一个包含8个水平的因子\n  x = rnorm(1000),         # 创建符合正态分布的x值\n  y = runif(1000)          # 创建符合均匀分布的y值\n)\n\n# 步骤1: 初始化图表, 提供因子和x轴数据\ncircos.initialize(factors = data$factor, x = data$x)\n\n# 步骤2: 构建绘图区域, 提供因子和y轴数据, 并使用 panel.fun 参数绘制坐标轴\ncircos.trackPlotRegion(\n  factors = data$factor,\n  y = data$y,\n  panel.fun = function(x, y) {\n    circos.axis()\n  }\n)\n\n# 步骤3: 在图表中添加散点\ncircos.trackPoints(data$factor, data$x, data$y,\n  col = \"blue\", # 设置点的颜色\n  pch = 16,     # 设置点的形状 (实心圆)\n  cex = 0.5     # 设置点的大小\n)\n```\n\n::: {.cell-output-display}\n![基础弦图](chord-diagram_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n### 自定义\n\n基础弦图:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 加载 circlize 包\nlibrary(circlize)\n\n# 创建示例数据集\ndata <- data.frame(\n  factor = sample(letters[1:8], 1000, replace = TRUE), # 创建一个包含8个水平的因子\n  x = rnorm(1000),                                     # 创建符合正态分布的x值\n  y = runif(1000)                                      # 创建符合均匀分布的y值\n)\n\n# 步骤1: 初始化图表, 提供因子和x轴数据\ncircos.initialize(factors = data$factor, x = data$x)\n\n# 步骤2: 构建绘图区域, 并绘制默认坐标轴\ncircos.trackPlotRegion(\n  factors = data$factor,\n  y = data$y,\n  panel.fun = function(x, y) {\n    circos.axis()\n  }\n)\n\n# 步骤3: 在图表中添加散点\ncircos.trackPoints(data$factor, data$x, data$y)\n```\n\n::: {.cell-output-display}\n![基础弦图](chord-diagram_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n自定义样式的弦图:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 加载 circlize 包\nlibrary(circlize)\n\n# 创建示例数据集\ndata <- data.frame(\n  factor = sample(letters[1:8], 1000, replace = TRUE), # 创建一个包含8个水平的因子\n  x = rnorm(1000),                                     # 创建符合正态分布的x值\n  y = runif(1000)                                      # 创建符合均匀分布的y值\n)\n\n# --- 全局参数自定义 ---\n# 使用 par() 函数设置全局绘图参数\npar(\n  mar = c(1, 1, 1, 1),          # 图表的外边距\n  bg = '#f5f5f5' # 图表的背景颜色\n)\n# 使用 circos.par() 函数设置 circlize 的特定参数\ncircos.par(\"track.height\" = 0.6) # 设置轨道高度为总高度的60%\n\n# 步骤1: 初始化图表, 提供因子和x轴数据\ncircos.initialize(factors = data$factor, x = data$x)\n\n# 步骤2: 构建绘图区域, 并在其中自定义坐标轴样式\ncircos.trackPlotRegion(\n  factors = data$factor,\n  y = data$y,\n  panel.fun = function(x, y) {\n    circos.axis(\n      h = \"top\",                       # x轴位于轨道的内侧还是外侧 (\"top\" 或 \"bottom\")\n      labels = TRUE,                   # 是否显示轴标签\n      major.tick = TRUE,               # 是否显示主刻度线\n      labels.cex = 0.5,                # 标签的缩放倍数 (值越大, 字体越大)\n      labels.font = 1,                 # 标签的字体样式 (1:常规, 2:粗体, 3:斜体, 4:粗斜体)\n      direction = \"outside\",           # 刻度线的方向, 指向圆外 (\"outside\") 或圆内 (\"inside\")\n      minor.ticks = 4,                 # 主刻度之间次要刻度的数量\n      major.tick.percentage = 0.1,     # 主刻度线长度占轨道高度的百分比\n      lwd = 2                          # 刻度线和x轴线的宽度\n    )\n  }\n)\n\n# 步骤3: 添加自定义样式的散点\ncircos.trackPoints(data$factor, data$x, data$y,\n  col = \"#69b3a2\", # 设置点的颜色\n  pch = 16,       # 设置点的形状 (实心圆)\n  cex = 0.5       # 设置点的大小\n)\n```\n\n::: {.cell-output-display}\n![自定义样式的弦图](chord-diagram_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n### 图类型\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 加载 circlize 包\nlibrary(circlize)\n# 设置轨道高度为总高度的40%\ncircos.par(\"track.height\" = 0.4)\n\n# 创建示例数据集\ndata <- data.frame(\n  factor = sample(letters[1:8], 1000, replace = TRUE), # 创建一个包含8个水平的因子\n  x = rnorm(1000),                                     # 创建符合正态分布的x值\n  y = runif(1000)                                      # 创建符合均匀分布的y值\n)\n\n# 步骤1: 初始化图表, 提供因子和x轴数据\ncircos.initialize(factors = data$factor, x = data$x)\n\n# 步骤2: 构建绘图区域, 并绘制默认坐标轴\ncircos.trackPlotRegion(\n  factors = data$factor,\n  y = data$y,\n  panel.fun = function(x, y) {\n    circos.axis()\n  }\n)\n\n# 步骤3: 添加散点\ncircos.trackPoints(data$factor, data$x, data$y, col = \"#69b3a2\")\n```\n\n::: {.cell-output-display}\n![圆形散点图](chord-diagram_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 加载 circlize 包\nlibrary(circlize)\n# 设置轨道高度为总高度的40%\ncircos.par(\"track.height\" = 0.4)\n\n# 创建示例数据集\ndata <- data.frame(\n  factor = sample(letters[1:8], 1000, replace = TRUE), # 创建一个包含8个水平的因子\n  x = rnorm(1000),                                     # 创建符合正态分布的x值\n  y = runif(1000)                                      # 创建符合均匀分布的y值\n)\n\n# 步骤1: 初始化图表, 提供因子和x轴数据\ncircos.initialize(factors = data$factor, x = data$x)\n\n# 步骤2: 构建绘图区域, 并绘制默认坐标轴\ncircos.trackPlotRegion(\n  factors = data$factor,\n  y = data$y,\n  panel.fun = function(x, y) {\n    circos.axis()\n  }\n)\n\n# 步骤3: 添加折线\n# 注意: 需要对x和y值按x的顺序进行排序, 以确保线条正确连接\ncircos.trackLines(data$factor,\n  data$x[order(data$x)],\n  data$y[order(data$x)],\n  col = rgb(0.1, 0.5, 0.8, 0.3), # 设置线条颜色和透明度\n  lwd = 2                        # 设置线条宽度\n)\n```\n\n::: {.cell-output-display}\n![圆形折线图](chord-diagram_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 加载 circlize 包\nlibrary(circlize)\n# 设置轨道高度为总高度的40%\ncircos.par(\"track.height\" = 0.4)\n\n# 创建示例数据集\ndata <- data.frame(\n  factor = sample(letters[1:8], 1000, replace = TRUE), # 创建一个包含8个水平的因子\n  x = rnorm(1000),                                     # 创建符合正态分布的x值\n  y = runif(1000)                                      # 创建符合均匀分布的y值\n)\n\n# 步骤1: 初始化图表, 提供因子和x轴数据\ncircos.initialize(factors = data$factor, x = data$x)\n\n# 步骤2: 构建绘图区域, 并绘制默认坐标轴\ncircos.trackPlotRegion(\n  factors = data$factor,\n  y = data$y,\n  panel.fun = function(x, y) {\n    circos.axis()\n  }\n)\n\n# 步骤3: 添加垂线\n# type = \"h\" 表示绘制从y=0到数据点的垂直线段\ncircos.trackLines(data$factor,\n  data$x[order(data$x)],\n  data$y[order(data$x)],\n  col = rgb(0.1, 0.5, 0.8, 0.3), # 设置线条颜色和透明度\n  lwd = 2,                       # 设置线条宽度\n  type = \"h\"                     # 设置线条类型为垂线\n)\n```\n\n::: {.cell-output-display}\n![圆形垂线图](chord-diagram_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 加载 circlize 包\nlibrary(circlize)\n# 设置轨道高度为总高度的40%\ncircos.par(\"track.height\" = 0.4)\n\n# 创建示例数据集\ndata <- data.frame(\n  factor = sample(letters[1:8], 1000, replace = TRUE), # 创建一个包含8个水平的因子\n  x = rnorm(1000),                                     # 创建符合正态分布的x值\n  y = runif(1000)                                      # y值在此图中未使用\n)\n\n# 步骤1: 初始化图表, 仅提供因子和x轴数据范围\ncircos.initialize(factors = data$factor, x = data$x)\n\n# 步骤2: 直接使用高级函数绘制直方图轨道\n# circos.trackHist 会自动创建轨道并计算和绘制直方图\ncircos.trackHist(data$factor,\n  data$x,\n  bg.col = \"white\", # 设置轨道的背景色\n  col = \"#69b3a2\"   # 设置直方图的填充色\n)\n```\n\n::: {.cell-output-display}\n![圆形直方图](chord-diagram_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n### 堆叠\n\n加载包并创建数据:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(circlize) # 加载 circlize 包\ncircos.clear()    # 清除当前的圆形布局, 避免图形叠加\n\n# 创建一个示例数据集\ndata <- data.frame(\n  factor = sample(letters[1:8], 1000, replace = TRUE), # 创建一个包含8个水平的因子变量\n  x = rnorm(1000),     # 创建一个符合正态分布的x变量\n  y = runif(1000)      # 创建一个符合均匀分布的y变量\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 初始化圆形图\npar(mar = c(1, 1, 1, 1)) # 设置图形边距\ncircos.initialize(\n  factors = data$factor, # 使用 factor 列作为圆形图的扇区\n  x = data$x             # 使用 x 列作为每个扇区的x轴范围\n)\n\n# --- 构建第一个轨道区域 ---\ncircos.trackPlotRegion(\n  factors = data$factor, # 指定扇区\n  y = data$y,            # 指定y轴数据, 用于确定轨道的高度范围\n  panel.fun = function(x, y) {\n    circos.axis(\n      labels.cex = 0.5, # 坐标轴标签字体大小\n      labels.font = 1,  # 坐标轴标签字体样式\n      lwd = 0.8         # 坐标轴线宽\n    )\n  }\n)\n\n# 在第一个轨道上添加散点\ncircos.trackPoints(\n  data$factor,                              # 指定扇区\n  data$x,                                   # 指定散点的x坐标\n  data$y,                                   # 指定散点的y坐标\n  col = rgb(0.1, 0.5, 0.8, 0.3),            # 设置点的颜色(含透明度)\n  pch = 20                                  # 设置点的形状为实心圆\n)\n\n# --- 构建第二个轨道区域 ---\ncircos.trackPlotRegion(\n  factors = data$factor, # 指定扇区\n  y = data$y,            # 指定y轴数据\n  panel.fun = function(x, y) {\n    circos.axis(\n      labels = FALSE,    # 不显示坐标轴标签\n      major.tick = FALSE # 不显示主要刻度线\n    )\n  }\n)\n\ncircos.trackPoints(\n  data$factor,                              # 指定扇区\n  data$x,                                   # 指定散点的x坐标\n  data$y,                                   # 指定散点的y坐标\n  col = rgb(0.9, 0.5, 0.8, 0.3),            # 设置不同的颜色\n  pch = 20,                                 # 设置点的形状\n  cex = 2                                   # 将点的大小设置为原来的2倍\n)\n\n# --- 构建第三个轨道区域 ---\n\n# 设置后续轨道的高度\ncircos.par(\"track.height\" = 0.4) # 将轨道高度设置为默认值的40%\n\n# 构建第三个轨道区域\ncircos.trackPlotRegion(\n  factors = data$factor, # 指定扇区\n  y = data$y,            # 指定y轴数据\n  panel.fun = function(x, y) {\n    circos.axis(\n      labels = FALSE,    # 不显示坐标轴标签\n      major.tick = FALSE # 不显示主要刻度线\n    )\n  }\n)\n\n# 在第三个轨道上添加垂线 (类似直方图)\ncircos.trackLines(\n  data$factor,                              # 指定扇区\n  data$x,                                   # 指定线的x坐标\n  data$y,                                   # 指定线的y坐标 (线的高度)\n  col = rgb(0.9, 0.5, 0.1, 0.3),            # 设置线的颜色\n  type = \"h\"                                # 设置类型为垂线\n)\n```\n\n::: {.cell-output-display}\n![初始化圆形图并添加第一个轨道, 轨道上绘制散点图](chord-diagram_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n### 拼图\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(circlize) # 加载 circlize 包\n\n# 设置绘图布局为 3x3 的矩阵\nlayout(matrix(1:9, 3, 3))\n\n# 循环 9 次, 创建 9 个独立的圆形图\nfor (i in 1:9) {\n  # 设置每个子图的边距(mar)和背景色(bg), 背景设为几乎透明\n  par(mar = c(0.5, 0.5, 0.5, 0.5), bg = rgb(1, 1, 1, 0.1))\n  \n  # 定义圆形图的扇区 (1到8)\n  factors <- 1:8\n  \n  # 设置扇区间的填充(padding)为0, 使它们紧密相连\n  circos.par(cell.padding = c(0, 0, 0, 0))\n  \n  # 初始化圆形图布局\n  circos.initialize(factors, xlim = c(0, 1))\n  \n  # 添加一个高度很小的轨道, 并为每个扇区设置随机背景色\n  circos.trackPlotRegion(\n    ylim = c(0, 1),             # Y轴范围\n    track.height = 0.05,        # 轨道高度设为0.05, 非常窄\n    bg.col = rand_color(8),     # 为8个扇区随机分配颜色\n    bg.border = NA              # 不显示轨道边框\n  )\n  \n  # 循环 20 次, 添加 20 条连接线(link)\n  for (i in 1:20) {\n    # 随机抽取两个扇区作为连接的起点和终点\n    se <- sample(1:8, 2)\n    # 在两个随机扇区的随机位置之间绘制连接线\n    circos.link(\n      se[1], runif(2), # 第一个扇区及连接带在该扇区上的起止位置\n      se[2], runif(2), # 第二个扇区及连接带在该扇区上的起止位置\n      col = rand_color(1, transparency = 0.4) # 设置连接带为随机的半透明颜色\n    )\n  }\n  \n  # 清除当前圆形图的参数, 以便开始下一次循环的绘制\n  circos.clear()\n}\n```\n\n::: {.cell-output-display}\n![使用循环和 layout 函数创建 9 个随机和弦图](chord-diagram_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\nlayout(1)\n```\n:::\n\n\n\n### 半圆\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(circlize) # 加载 circlize 包\n\n# --- 1. 数据准备 ---\nfactors <- letters[1:4] # 创建扇区标识符 (a, b, c, d)\nx1 <- runif(100)        # 创建用于绘图的随机x坐标\ny1 <- runif(100)        # 创建用于绘图的随机y坐标\n\n# --- 2. 全局参数设置 ---\n# 设置图形边距\npar(mar = c(1, 2, 0.1, 0.1))\n\n# 设置circlize的全局参数, 实现\"缩放\"效果\ncircos.par(\n  \"track.height\" = 0.7,      # 设置轨道高度\n  \"canvas.xlim\" = c(0, 1),   # 设置画布在x方向的可见范围, 类似缩放\n  \"canvas.ylim\" = c(0, 1),   # 设置画布在y方向的可见范围\n  \"gap.degree\" = 0,          # 扇区之间无间隙\n  \"clock.wise\" = FALSE       # 扇区逆时针排列\n)\n\n# --- 3. 绘图与更新 ---\n# 初始化圆形图, 但不绘制边框\ncircos.initialize(factors = factors, xlim = c(0, 1))\ncircos.trackPlotRegion(\n  factors = factors,\n  ylim = c(0, 1),\n  bg.border = NA # 初始时不绘制任何扇区的边框\n)\n\n# 单独更新扇区 \"a\" 的样式, 使其边框可见, 从而突出显示\ncircos.updatePlotRegion(\n  sector.index = \"a\",      # 指定要更新的扇区\n  bg.border = \"grey\",      # 将其背景边框颜色设为灰色\n  bg.lwd = 0.2             # 设置边框线宽\n)\n\n# --- 4. 在更新后的扇区中添加图形元素 ---\n# 在当前活跃的扇区 (\"a\") 中添加垂线\ncircos.lines(\n  x1,\n  y1,\n  type = \"h\",                       # 类型为垂线\n  col = \"#69b3a2\",                  # 设置颜色\n  lwd = 3                           # 设置线宽\n)\n\n# 为当前扇区添加坐标轴\ncircos.axis(\n  h = \"bottom\",                     # 坐标轴位于扇区底部\n  labels.cex = 0.4,                 # 标签字体大小\n  direction = \"inside\"              # 刻度线和标签朝向圆心\n)\n```\n\n::: {.cell-output-display}\n![通过设置画布参数实现缩放效果, 并单独更新扇区 a 的样式以突出显示](chord-diagram_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# --- 5. 清理 ---\n# 清除布局, 为下一个图做准备\ncircos.clear()\n```\n:::\n\n\n\n\n## 静态\n\n### 介绍\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 加载 circlize 包\nlibrary(circlize)\n\n# 创建数据集\nset.seed(123) # 设置随机数种子以保证结果的可复现性\ndata <- data.frame( # 创建一个数据框\n  factor = sample(letters[1:8], 1000, replace = TRUE), # 从 a-h 8个字母中随机抽样1000次, 作为因子变量\n  x = rnorm(1000), # 生成1000个符合正态分布的x值\n  y = runif(1000) # 生成1000个符合均匀分布的y值\n)\n\n# 初始化图表\npar(mar = c(1, 1, 1, 1)) # 设置图形边距\ncircos.initialize( # 初始化圆形布局\n  factors = data$factor, # 指定因子(扇区)\n  x = data$x # 指定每个扇区的x轴范围\n)\n\n# 构建第一个轨道区域\ncircos.trackPlotRegion( # 创建一个绘图轨道\n  factors = data$factor, # 指定因子\n  y = data$y, # 指定y轴的值\n  bg.col = rgb(0.1, 0.1, seq(0, 1, 0.1), 0.4), # 设置背景颜色, 并带有透明度\n  bg.border = NA # 不显示轨道边框\n)\n\n# 添加一个点到另一个点之间的链接\ncircos.link(\n  \"a\", 0, # 第一个链接点: \"a\" 扇区, 位置 0\n  \"b\", 0, # 第二个链接点: \"b\" 扇区, 位置 0\n  h = 0.4 # 设置链接弧线的高度\n)\n\n# 添加一个点到一个区域之间的链接\ncircos.link(\n  \"e\", 0, # 第一个链接点: \"e\" 扇区, 位置 0\n  \"g\", c(-1, 1), # 第二个链接区域: \"g\" 扇区, 范围 -1 到 1\n  col = \"green\", # 设置链接颜色为绿色\n  lwd = 2, # 设置线宽为 2\n  lty = 2, # 设置线型为虚线\n  border = \"black\" # 设置链接区域的边框颜色\n)\n\n# 添加一个区域到另一个区域之间的链接\ncircos.link(\n  \"c\", c(-0.5, 0.5), # 第一个链接区域: \"c\" 扇区, 范围 -0.5 到 0.5\n  \"d\", c(-0.5, 0.5), # 第二个链接区域: \"d\" 扇区, 范围 -0.5 到 0.5\n  col = \"red\", # 设置链接颜色为红色\n  border = \"blue\", # 设置链接区域的边框颜色为蓝色\n  h = 0.2 # 设置链接弧线的高度\n)\n```\n\n::: {.cell-output-display}\n![使用 `circlize` 包在圆形布局中添加不同类型的链接](chord-diagram_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n### 基本\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 创建一个邻接矩阵:\n# 包含20个起点节点和5个终点节点之间的连接\nnumbers <- sample(c(1:1000), 100, replace = TRUE) # 从1到1000中随机抽取100个数字,允许重复\ndata <- matrix(numbers, ncol = 5) # 将这些数字放入一个5列的矩阵中\nrownames(data) <- paste0(\"orig-\", seq(1, 20))    # 设置行名, 代表起点\ncolnames(data) <- paste0(\"dest-\", seq(1, 5))     # 设置列名, 代表终点\n\n# 加载 circlize 包\nlibrary(circlize)\n\n# 绘制圆形弦图\nchordDiagram(data, transparency = 0.5) # 设置图形透明度为0.5\n```\n\n::: {.cell-output-display}\n![从邻接矩阵生成的弦图](chord-diagram_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 创建一个边缘列表:\n# 包含10个起点节点和10个终点节点之间的连接\norigin <- paste0(\"orig \", sample(c(1:10), 20, replace = TRUE))      # 创建20个随机的起点\ndestination <- paste0(\"dest \", sample(c(1:10), 20, replace = TRUE)) # 创建20个随机的终点\ndata <- data.frame(origin, destination)      # 将起点和终点合并为数据框\n\n# 将输入数据转换为邻接矩阵\nadjacencyData <- with(data, table(origin, destination))\n\n# 加载 circlize 包\nlibrary(circlize)\n\n# 绘制圆形弦图\nchordDiagram(adjacencyData, transparency = 0.5) # 设置图形透明度为0.5\n```\n\n::: {.cell-output-display}\n![从边缘列表生成的弦图](chord-diagram_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n### 定制\n\n创建复杂弦图 (Chord Diagram) : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- 1. 加载库并创建初始数据框 ---\n\n# 加载研究所需的 R 包\nlibrary(circlize) # 主要用于绘制弦图\n# install.packages(\"migest\")\nlibrary(migest)   # 此处可能用于数据处理, 但在后续代码未直接使用\nlibrary(dplyr)    # 用于数据整理和操作\n\n# 创建一个数据框 m\n# 包含了国家名称、顺序、移民数据以及用于绘图的RGB颜色值\nm <- data.frame(\n  order = 1:6,\n  country = c(\"Ausralia\", \"India\", \"China\", \"Japan\", \"Thailand\", \"Malaysia\"),\n  V3 = c(1, 150000, 90000, 180000, 15000, 10000),\n  V4 = c(35000, 1, 10000, 12000, 25000, 8000),\n  V5 = c(10000, 7000, 1, 40000, 5000, 4000),\n  V6 = c(7000, 8000, 175000, 1, 11000, 18000),\n  V7 = c(70000, 30000, 22000, 120000, 1, 40000),\n  V8 = c(60000, 90000, 110000, 14000, 30000, 1),\n  r = c(255, 255, 255, 153, 51, 51),\n  g = c(51, 153, 255, 255, 255, 255),\n  b = c(51, 51, 51, 51, 51, 153),\n  stringsAsFactors = FALSE\n)\n\n\n# --- 2. 将数据框处理成绘图所需的矩阵格式 ---\n\n# 提取国家、顺序和颜色信息到 df1\ndf1 <- m[, c(1, 2, 9:11)]\n\n# 从 m 中移除元数据列, 并将数值除以 1e04 进行缩放\nm <- m[, -(1:2)] / 1e04\nm <- as.matrix(m[, c(1:6)]) # 将数据框转换为矩阵\n\n# 为矩阵设置行名和列名, 分别代表起点和终点国家\ndimnames(m) <- list(orig = df1$country, dest = df1$country)\n\n# 根据 order 列对 df1 进行排序, 并将 country 列转换为因子类型以固定顺序\ndf1 <- arrange(df1, order)\ndf1$country <- factor(df1$country, levels = df1$country)\n\n# 确保矩阵 m 的行和列顺序与 df1 严格一致\nm <- m[levels(df1$country), levels(df1$country)]\n\n\n# --- 3. 设置 circos 图的扇区范围和颜色 ---\n\n# 计算每个扇区的 x 轴范围 (xmin, xmax)\n# 扇区的总长度等于该国所有流出量和所有流入量的总和\ndf1$xmin <- 0\ndf1$xmax <- rowSums(m) + colSums(m)\n\n# 获取国家数量\nn <- nrow(df1)\n\n# 使用 rgb() 函数根据 r, g, b 列创建扇区的填充颜色 (rcol)\ndf1$rcol <- rgb(df1$r, df1$g, df1$b, max = 255)\n# 创建带有透明度的链接颜色 (lcol)\ndf1$lcol <- rgb(df1$r, df1$g, df1$b, alpha = 200, max = 255)\n\n\n# --- 4. 绘制弦图的外部扇区、标签和坐标轴 ---\n\n# 设置绘图区域的边距为0\npar(mar = rep(0, 4))\n# 清除当前的 circos 绘图设备\ncircos.clear()\n\n# 设置基本的 circos 图形参数\ncircos.par(\n  cell.padding = c(0, 0, 0, 0), # 单元格边距\n  track.margin = c(0, 0.15),   # 轨道边距\n  start.degree = 90,           # 起始角度\n  gap.degree = 4               # 扇区之间的间隙大小\n)\n\n# 初始化 circos 布局\ncircos.initialize(factors = df1$country, xlim = cbind(df1$xmin, df1$xmax))\n\n# 绘制扇区轨道\ncircos.trackPlotRegion(\n  ylim = c(0, 1),\n  factors = df1$country,\n  track.height = 0.1,\n  # panel.fun 会为每个扇区执行一次\n  panel.fun = function(x, y) {\n    # 获取当前扇区的元数据\n    name <- get.cell.meta.data(\"sector.index\")\n    i <- get.cell.meta.data(\"sector.numeric.index\")\n    xlim <- get.cell.meta.data(\"xlim\")\n    ylim <- get.cell.meta.data(\"ylim\")\n\n    # 根据角度判断文本显示方向 (dd) 和对齐方式 (aa)\n    theta <- circlize(mean(xlim), 1.3)[1, 1] %% 360\n    dd <- ifelse(theta < 90 || theta > 270, \"clockwise\", \"reverse.clockwise\")\n    aa <- c(1, 0.5)\n    if (theta < 90 || theta > 270) {\n      aa <- c(0, 0.5)\n    }\n\n    # 绘制国家标签\n    circos.text(\n      x = mean(xlim), y = 1.7, labels = name,\n      facing = dd, cex = 0.6, adj = aa\n    )\n\n    # 绘制主扇区矩形\n    circos.rect(\n      xleft = xlim[1], ybottom = ylim[1], xright = xlim[2], ytop = ylim[2],\n      col = df1$rcol[i], border = df1$rcol[i]\n    )\n\n    # 在主扇区中绘制一个白色矩形, 用于区分流入和流出\n    circos.rect(\n      xleft = xlim[1], ybottom = ylim[1], xright = xlim[2] - rowSums(m)[i], ytop = ylim[1] + 0.3,\n      col = \"white\", border = \"white\"\n    )\n\n    # 在内圈绘制一圈白色细线\n    circos.rect(xleft = xlim[1], ybottom = 0.3, xright = xlim[2], ytop = 0.32, col = \"white\", border = \"white\")\n\n    # 绘制坐标轴 (已移除无效参数)\n    circos.axis(\n      labels.cex = 0.6, direction = \"outside\",\n      major.at = seq(from = 0, to = floor(df1$xmax)[i], by = 5),\n      minor.ticks = 1\n    )\n  }\n)\n\n# --- 5. 绘制国家之间的流量链接 ---\n\n# 在 df1 中添加 sum1 和 sum2 列, 用于标记链接的起始位置\n# sum1 用于流出链接, sum2 用于流入链接\ndf1$sum1 <- colSums(m)\ndf1$sum2 <- numeric(n)\n\n# 创建一个长格式的数据框 df2, 并按流量大小 (m) 降序排列\n# 这样做可以确保流量最大的链接最先被绘制, 避免被覆盖\ndf2 <- cbind(as.data.frame(m), orig = rownames(m), stringsAsFactors = FALSE)\ndf2 <- reshape(df2,\n  idvar = \"orig\", varying = list(1:n), direction = \"long\",\n  timevar = \"dest\", time = rownames(m), v.names = \"m\"\n)\ndf2 <- arrange(df2, desc(m))\n\n# 为了避免图形混乱, 只保留大于60%分位数的流量数据\ndf2 <- subset(df2, m > quantile(m, 0.6))\n\n# 循环绘制每个链接\nfor (k in 1:nrow(df2)) {\n  # 获取当前流量的起点(i)和终点(j)索引\n  i <- match(df2$orig[k], df1$country)\n  j <- match(df2$dest[k], df1$country)\n\n  # 绘制链接\n  circos.link(\n    sector.index1 = df1$country[i],\n    point1 = c(df1$sum1[i], df1$sum1[i] + abs(m[i, j])),\n    sector.index2 = df1$country[j],\n    point2 = c(df1$sum2[j], df1$sum2[j] + abs(m[i, j])),\n    col = df1$lcol[i]\n  )\n\n  # 更新 sum1 和 sum2 的值, 以便下一个链接能正确地堆叠在前一个链接之上\n  df1$sum1[i] <- df1$sum1[i] + abs(m[i, j])\n  df1$sum2[j] <- df1$sum2[j] + abs(m[i, j])\n}\n```\n\n::: {.cell-output-display}\n![复杂弦图](chord-diagram_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n### Migration\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# -- 1. 加载所需的库 --\nlibrary(tidyverse)    # 用于数据整理和转换, 核心包\nlibrary(viridis)      # 提供美观的调色板\nlibrary(patchwork)    # 用于组合图形 (此示例未直接使用, 但通常有用)\nlibrary(hrbrthemes)   # 提供主题 (此示例未直接使用)\nlibrary(circlize)     # 绘制弦图的核心包\n# remotes::install_github(\"mattflor/chorddiag\")\nlibrary(chorddiag)    # 用于绘制交互式弦图 (在第二个例子中使用)\n\n\n# -- 2. 从 Github 加载数据集 --\n# 这是一个邻接矩阵, 表示地区间的流量\ndata <- read.table(\"https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/13_AdjacencyDirectedWeighted.csv\", header = TRUE)\n\n# -- 3. 数据预处理 --\n# 缩短列名以便在图上更好地显示\nshort_names <- c(\"Africa\", \"East Asia\", \"Europe\", \"Latin Ame.\", \"North Ame.\", \"Oceania\", \"South Asia\", \"South East Asia\", \"Soviet Union\", \"West.Asia\")\ncolnames(data) <- short_names\nrownames(data) <- short_names\n\n# 将邻接矩阵 (宽格式) 转换为长格式, 这是 circlize 函数需要的格式\ndata_long <- data |>\n  rownames_to_column() |>\n  gather(key = \"key\", value = \"value\", -rowname)\n\n# -- 4. 绘图参数设置 --\ncircos.clear() # 清除之前的 circos 图形, 重置参数\ncircos.par(\n  start.degree = 90,                   # 从90度角开始绘制, 即顶部\n  gap.degree = 4,                      # 扇区之间的间隙大小\n  track.margin = c(-0.1, 0.1),         # 轨道的内外边距\n  points.overflow.warning = FALSE      # 关闭因点超出范围而产生的警告\n)\npar(mar = rep(0, 4)) # 设置图形边距为0, 使图形充满整个绘图区域\n\n# 创建一个调色板\nmycolor <- viridis(10, alpha = 1, begin = 0, end = 1, option = \"D\")\nmycolor <- mycolor[sample(1:10)] # 随机打乱颜色顺序\n\n# -- 5. 绘制基础弦图 --\nchordDiagram(\n  x = data_long,                         # 使用长格式数据\n  grid.col = mycolor,                    # 设置每个扇区的颜色\n  transparency = 0.25,                   # 设置链接的透明度\n  directional = 1,                       # 设置链接为有方向性\n  direction.type = c(\"arrows\", \"diffHeight\"), # 方向性通过箭头和高度差两种方式表示\n  diffHeight = -0.04,                    # 链接两端的高度差\n  annotationTrack = \"grid\",              # 在网格上添加注释轨道\n  annotationTrackHeight = c(0.05, 0.1),  # 注释轨道的高度\n  link.arr.type = \"big.arrow\",           # 使用大箭头样式\n  link.sort = TRUE,                      # 对链接进行排序\n  link.largest.ontop = TRUE              # 将最大的链接绘制在最上层\n)\n\n# -- 6. 在注释轨道上添加文本和坐标轴 --\ncircos.trackPlotRegion(\n  track.index = 1,                       # 在第一个轨道上操作\n  bg.border = NA,                        # 不绘制轨道背景的边框\n  panel.fun = function(x, y) {           # 对每个扇区执行的函数\n    xlim <- get.cell.meta.data(\"xlim\")\n    sector.index <- get.cell.meta.data(\"sector.index\")\n\n    # 添加扇区名称\n    circos.text(\n      x = mean(xlim),                    # 文本位于扇区中间\n      y = 3.2,                           # 文本的 Y 坐标 (可以调整以改变距离)\n      labels = sector.index,             # 文本内容为扇区名称\n      facing = \"bending\",                # 文本方向沿扇区弯曲\n      cex = 0.8                          # 文本大小\n    )\n\n    # 添加坐标轴刻度\n    circos.axis(\n      h = \"top\",                         # 刻度线朝外\n      # 动态设置刻度间隔: 如果扇区范围大于10, 则间隔为2, 否则为1\n      major.at = seq(from = 0, to = xlim[2], by = ifelse(test = xlim[2] > 10, yes = 2, no = 1)),\n      minor.ticks = 1,                   # 主刻度之间的小刻度数量\n      major.tick.percentage = 0.5,       # 主刻度线长度占轨道高度的百分比\n      labels.niceFacing = FALSE          # 不自动优化标签方向\n    )\n  }\n)\n```\n\n::: {.cell-output-display}\n![使用 circlize 包绘制的全球人口迁移弦图](chord-diagram_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 加载 chorddiag 包\nlibrary(chorddiag)\n\n# 创建一个 4x4 的矩阵\n# 数据代表拥有某种发色的人群, 对不同发色的偏好\nm <- matrix(c(\n  11975, 5871, 8916, 2868,\n  1951, 10048, 2060, 6171,\n  8010, 16145, 8090, 8045,\n  1013, 990, 940, 6907\n),\nbyrow = TRUE,\nnrow = 4, ncol = 4\n)\n\n# 定义分组名称和颜色\nhaircolors <- c(\"black\", \"blonde\", \"brown\", \"red\")\ngroupColors <- c(\"#000000\", \"#FFDD89\", \"#957244\", \"#F26223\")\n\n# 为矩阵设置行名和列名\ndimnames(m) <- list(\n  have = haircolors,\n  prefer = haircolors\n)\n\n# 绘制交互式弦图\nchorddiag(m,\n  groupColors = groupColors,      # 指定分组颜色\n  groupnamePadding = 20           # 分组名称与图形的间距\n)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"chorddiag html-widget html-fill-item\" id=\"htmlwidget-63274a05308b361c00c2\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-63274a05308b361c00c2\">{\"x\":{\"matrix\":[[11975,5871,8916,2868],[1951,10048,2060,6171],[8010,16145,8090,8045],[1013,990,940,6907]],\"options\":{\"type\":\"directional\",\"width\":null,\"height\":null,\"margin\":100,\"showGroupnames\":true,\"groupNames\":[\"black\",\"blonde\",\"brown\",\"red\"],\"groupColors\":[\"#000000\",\"#FFDD89\",\"#957244\",\"#F26223\"],\"groupThickness\":0.1,\"groupPadding\":0.03490658503988659,\"groupnamePadding\":[20,20,20,20],\"groupnameFontsize\":18,\"groupedgeColor\":null,\"chordedgeColor\":\"#808080\",\"categoryNames\":null,\"categorynamePadding\":100,\"categorynameFontsize\":28,\"showTicks\":true,\"tickInterval\":1000,\"ticklabelFontsize\":10,\"fadeLevel\":0.1,\"showTooltips\":true,\"showZeroTooltips\":true,\"tooltipNames\":[\"black\",\"blonde\",\"brown\",\"red\"],\"tooltipFontsize\":12,\"tooltipUnit\":\"\",\"tooltipGroupConnector\":\" &#x25B6; \",\"precision\":\"null\",\"clickAction\":null,\"clickGroupAction\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n\n使用 chorddiag 包绘制的头发颜色偏好交互式弦图\n:::\n:::\n\n\n\n\n\n## 交互\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 加载 chorddiag 包\n# 如果尚未安装, 请执行 install.packages(\"chorddiag\")\n# 或者从 Github 安装最新版: devtools::install_github(\"mattflor/chorddiag\")\nlibrary(chorddiag)\n\n# 创建一个 4x4 的数据矩阵 m\n# 行代表拥有某种发色的人群, 列代表他们偏好的发色\nm <- matrix(c(\n  11975, 5871, 8916, 2868,\n  1951, 10048, 2060, 6171,\n  8010, 16145, 8090, 8045,\n  1013, 990, 940, 6907\n),\nbyrow = TRUE,\nnrow = 4, ncol = 4\n)\n\n# 创建一个向量, 用于定义4个分组的名称\nhaircolors <- c(\"black\", \"blonde\", \"brown\", \"red\")\n\n# 为矩阵 m 的行和列设置维度名称\ndimnames(m) <- list(\n  have = haircolors,\n  prefer = haircolors\n)\n\n# 创建一个包含4种颜色的向量, 与分组一一对应\ngroupColors <- c(\"#000000\", \"#FFDD89\", \"#957244\", \"#F26223\")\n\n# 调用 chorddiag 函数构建弦图, 并将其赋值给变量 p\np <- chorddiag(m,\n  groupColors = groupColors, # 指定分组颜色\n  groupnamePadding = 20      # 分组名称与图形的间距\n)\n\n# 显示图形 (在 RStudio Viewer 或浏览器中)\np\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"chorddiag html-widget html-fill-item\" id=\"htmlwidget-c5f7db01c7dee1edb330\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-c5f7db01c7dee1edb330\">{\"x\":{\"matrix\":[[11975,5871,8916,2868],[1951,10048,2060,6171],[8010,16145,8090,8045],[1013,990,940,6907]],\"options\":{\"type\":\"directional\",\"width\":null,\"height\":null,\"margin\":100,\"showGroupnames\":true,\"groupNames\":[\"black\",\"blonde\",\"brown\",\"red\"],\"groupColors\":[\"#000000\",\"#FFDD89\",\"#957244\",\"#F26223\"],\"groupThickness\":0.1,\"groupPadding\":0.03490658503988659,\"groupnamePadding\":[20,20,20,20],\"groupnameFontsize\":18,\"groupedgeColor\":null,\"chordedgeColor\":\"#808080\",\"categoryNames\":null,\"categorynamePadding\":100,\"categorynameFontsize\":28,\"showTicks\":true,\"tickInterval\":1000,\"ticklabelFontsize\":10,\"fadeLevel\":0.1,\"showTooltips\":true,\"showZeroTooltips\":true,\"tooltipNames\":[\"black\",\"blonde\",\"brown\",\"red\"],\"tooltipFontsize\":12,\"tooltipUnit\":\"\",\"tooltipGroupConnector\":\" &#x25B6; \",\"precision\":\"null\",\"clickAction\":null,\"clickGroupAction\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n\n不同发色人群的发色偏好交互式弦图\n:::\n:::\n\n\n## Pearl\n\n[![Character Interaction Analysis](./image/character-interaction-analysis.png)](https://r-graph-gallery.com/character-interaction-analysis.html)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"site_libs/d3-4.13.0/d3.min.js\"></script>\n<script src=\"site_libs/d3-tip-0.8.1/index.js\"></script>\n<link href=\"site_libs/chorddiag-0.1.2.9000/chorddiag.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/chorddiag-0.1.2.9000/chorddiag.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}