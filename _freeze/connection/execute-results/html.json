{
  "hash": "82c25d7af9c3236146dec90b12c380b2",
  "result": {
    "engine": "knitr",
    "markdown": "# Connection {#sec-connection}\n\n## PKG \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)     # 数据处理\nlibrary(maps)      # 地图绘制\nlibrary(geosphere) # 地理计算\n```\n:::\n\n\n## Step\n\n### 绘制空白地图\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 无边距设置\npar(mar=c(0,0,0,0))\n\n# 绘制世界地图\nmap('world',\n    col=\"#f2f2f2\",     # 陆地颜色：浅灰色\n    fill=TRUE,         # 填充陆地\n    bg=\"white\",        # 背景颜色：白色\n    lwd=0.05,          # 线条宽度\n    mar=rep(0,4),      # 边距设置\n    border=0,          # 边框设置\n    ylim=c(-80,80)     # 纬度范围限制\n)\n```\n\n::: {.cell-output-display}\n![绘制世界地图背景](connection_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n### 添加3个城市\n\n使用points()函数在特定位置添加圆圈相对简单。最困难的部分可能是找出您感兴趣的城市的经度和纬度。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 定义城市坐标（经度，纬度）\nBuenos_aires <- c(-58,-34)    # 布宜诺斯艾利斯\nParis <- c(2,49)              # 巴黎\nMelbourne <- c(145,-38)       # 墨尔本\n\n# 创建数据框\ndata <- rbind(Buenos_aires, Paris, Melbourne) |> \n  as.data.frame()\ncolnames(data) <- c(\"long\",\"lat\")  # 设置列名：经度和纬度\n\n# 在地图上显示城市\nmap('world',\n    col=\"#f2f2f2\", fill=TRUE, bg=\"white\", lwd=0.05,\n    mar=rep(0,4),border=0, ylim=c(-80,80) \n)\n# 添加城市点标记\npoints(x=data$long, y=data$lat, col=\"slateblue\", cex=3, pch=20)\n```\n\n::: {.cell-output-display}\n![在地图上标记城市位置](connection_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n### 显示城市之间的连接\n\n现在我们可以通过绘制城市间的最短路线来连接城市。这是使用大圆弧完成的，比使用直线提供更好的可视化效果。\n\n`geosphere` 包提供了 `gcIntermediate()` 函数来计算路径。然后可以使用 `lines()` 函数绘制此路径。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 背景地图\nmap('world',\n    col=\"#f2f2f2\", fill=TRUE, bg=\"white\", lwd=0.05,\n    mar=rep(0,4),border=0, ylim=c(-80,80) \n)\n\n# 城市点标记\npoints(x=data$long, y=data$lat, col=\"slateblue\", cex=3, pch=20)\n\n# 计算布宜诺斯艾利斯和巴黎之间的连接\ninter <- gcIntermediate(\n    Paris, Buenos_aires, \n    n=50,              # 路径上的点数\n    addStartEnd=TRUE,  # 包含起点和终点\n    breakAtDateLine=F  # 不在日期变更线处断开\n)\n\n# 显示这个连接\nlines(inter, col=\"slateblue\", lwd=2)\n \n# 巴黎和墨尔本之间的连接\ninter <- gcIntermediate(Melbourne, Paris, n=50, addStartEnd=TRUE, breakAtDateLine=F)             \nlines(inter, col=\"slateblue\", lwd=2)\n```\n\n::: {.cell-output-display}\n![绘制城市间的连接线](connection_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n### 修正gcIntermediate函数\n\n在墨尔本和布宜诺斯艾利斯之间使用完全相同的方法, 结果不太好\n\n会出现一条长水平线，而我们期望连接在地球的另一侧完成（因此不可见）。\n\n原因是 `gcintermediate` 遵循最短路径，这意味着它将从澳大利亚向东行进直到日期线，断开线条并从太平洋向东返回到南美洲。\n\n因为我们不想看到水平线，我们需要分两步绘制此连接。\n\n为此，我们可以使用以下函数，当两点之间的距离超过180度时，该函数将线条分为两部分：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 绘制连接的函数\nplot_my_connection=function( dep_lon, dep_lat, arr_lon, arr_lat, ...){\n    # 计算两点间的大圆弧路径\n    inter <- gcIntermediate(c(dep_lon, dep_lat), c(arr_lon, arr_lat), \n                           n=50, addStartEnd=TRUE, breakAtDateLine=F)             \n    inter=data.frame(inter)\n    \n    # 计算经度差异\n    diff_of_lon=abs(dep_lon) + abs(arr_lon)\n    \n    # 如果经度差异大于180度，分两段绘制以避免跨越地图边界的直线\n    if(diff_of_lon > 180){\n        lines(subset(inter, lon>=0), ...)  # 绘制东半球部分\n        lines(subset(inter, lon<0), ...)   # 绘制西半球部分\n    }else{\n        lines(inter, ...)                  # 正常绘制整条线\n        }\n    }\n```\n:::\n\n\n让我们应用这个函数来绘制墨尔本和布宜诺斯艾利斯之间的链接。\n\n好多啦!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 背景地图\nmap('world',col=\"#f2f2f2\", fill=TRUE, bg=\"white\", lwd=0.05,mar=rep(0,4),border=0, ylim=c(-80,80) )\n\n# 城市圆圈标记\npoints(x=data$long, y=data$lat, col=\"slateblue\", cex=3, pch=20)\n \n# 绘制连接线\nplot_my_connection(Paris[1], Paris[2], Melbourne[1], Melbourne[2], col=\"slateblue\", lwd=2)\nplot_my_connection(Buenos_aires[1], Buenos_aires[2], Melbourne[1], Melbourne[2], col=\"slateblue\", lwd=2)\nplot_my_connection(Buenos_aires[1], Buenos_aires[2], Paris[1], Paris[2], col=\"slateblue\", lwd=2)\n```\n\n::: {.cell-output-display}\n![使用改进函数绘制全球连接](connection_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n### 应用到多对城市\n\n如果我们想绘制许多连接，完全可以构建一个for循环来逐一绘制它们。\n\n此外，请注意使用text函数添加城市名称。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 创建扩展数据集，包含更多城市\ndata <- rbind(\n    Buenos_aires=c(-58,-34),        # 布宜诺斯艾利斯\n    Paris=c(2,49),                  # 巴黎\n    Melbourne=c(145,-38),           # 墨尔本\n    Saint.Petersburg=c(30.32, 59.93),  # 圣彼得堡\n    Abidjan=c(-4.03, 5.33),         # 阿比让\n    Montreal=c(-73.57, 45.52),      # 蒙特利尔\n    Nairobi=c(36.82, -1.29),        # 内罗毕\n    Salvador=c(-38.5, -12.97)       # 萨尔瓦多\n    ) |> as.data.frame()            # 使用新管道操作符\ncolnames(data)=c(\"long\",\"lat\")\n\n# 生成所有城市对的坐标组合\nall_pairs <- cbind(t(combn(data$long, 2)), t(combn(data$lat, 2))) |> as.data.frame()\ncolnames(all_pairs) <- c(\"long1\",\"long2\",\"lat1\",\"lat2\")\n\n# 背景地图\npar(mar=c(0,0,0,0))\nmap('world',col=\"#f2f2f2\", fill=TRUE, bg=\"white\", lwd=0.05,mar=rep(0,4),border=0, ylim=c(-80,80) )\n \n# 添加所有连接线：\n# 遍历所有城市对，绘制它们之间的连接\nfor(i in 1:nrow(all_pairs)){\n    plot_my_connection(all_pairs$long1[i], all_pairs$lat1[i], \n                      all_pairs$long2[i], all_pairs$lat2[i], \n                      col=\"skyblue\", lwd=1)\n    }\n \n# 添加城市点和名称\npoints(x=data$long, y=data$lat, col=\"slateblue\", cex=2, pch=20)\ntext(rownames(data), x=data$long, y=data$lat, col=\"slateblue\", cex=1, pos=4)\n```\n\n::: {.cell-output-display}\n![多城市间的连接网络](connection_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n### 使用greatCircle函数的替代方法\n\n这是Simply Statistics博客建议的绘制Twitter连接地图的方法。\n\n思路是计算整个大圆弧，并只保留停留在地图前面的部分，永远不会到背面。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Jeff Leek提出的保留大圆弧正确部分的函数：\ngetGreatCircle <- function(userLL,relationLL){\n  # 计算完整的大圆弧路径（200个点）\n  tmpCircle = greatCircle(userLL,relationLL, n=200)\n  \n  # 找到起点在大圆弧中的位置\n  start = which.min(abs(tmpCircle[,1] - data.frame(userLL)[1,1]))\n  # 找到终点在大圆弧中的位置\n  end = which.min(abs(tmpCircle[,1] - relationLL[1]))\n  \n  # 提取起点到终点之间的路径部分\n  greatC = tmpCircle[start:end,]\n  return(greatC)\n}\n \n# 背景地图\nmap('world',col=\"#f2f2f2\", fill=TRUE, bg=\"white\", lwd=0.05,mar=rep(0,4),border=0, ylim=c(-80,80) )\n\n# 绘制3个连接：\ngreat <- getGreatCircle(Paris, Melbourne)\nlines(great, col=\"skyblue\", lwd=2)\n\ngreat <- getGreatCircle(Buenos_aires, Melbourne)\nlines(great, col=\"skyblue\", lwd=2)\n\ngreat <- getGreatCircle(Paris, Buenos_aires)\nlines(great, col=\"skyblue\", lwd=2)\n\n# 城市名称和点标记\npoints(x=data$long, y=data$lat, col=\"slateblue\", cex=3, pch=20)\ntext(rownames(data), x=data$long, y=data$lat, col=\"slateblue\", cex=1, pos=4)\n```\n\n::: {.cell-output-display}\n![使用greatCircle函数的替代连接方法](connection_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## Pearl\n\n[![](./image/surfer-travel.png)](https://www.data-to-viz.com/story/MapConnection.html)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}